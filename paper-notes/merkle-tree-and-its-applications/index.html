<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Merkle Tree and It’s Applications · Vivek Kumar Singh
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vivek Kumar Singh">
<meta name="description" content="A Merkle tree, also known as hash tree is a hash based data structure. It is a tree data structure in which each node leaf nodes are cryptographic hash of data blocks for example a file or set of files, and each non-leaf node is cryptographic hash on its children nodes. A hash tree allows efficient and secure verification of the contents of a large data structure.
Merkle trees are used in distributed systems for efficient data verification.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Merkle Tree and It’s Applications"/>
<meta name="twitter:description" content="A Merkle tree, also known as hash tree is a hash based data structure. It is a tree data structure in which each node leaf nodes are cryptographic hash of data blocks for example a file or set of files, and each non-leaf node is cryptographic hash on its children nodes. A hash tree allows efficient and secure verification of the contents of a large data structure.
Merkle trees are used in distributed systems for efficient data verification."/>

<meta property="og:title" content="Merkle Tree and It’s Applications" />
<meta property="og:description" content="A Merkle tree, also known as hash tree is a hash based data structure. It is a tree data structure in which each node leaf nodes are cryptographic hash of data blocks for example a file or set of files, and each non-leaf node is cryptographic hash on its children nodes. A hash tree allows efficient and secure verification of the contents of a large data structure.
Merkle trees are used in distributed systems for efficient data verification." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.viveksyngh.com/paper-notes/merkle-tree-and-its-applications/" /><meta property="article:section" content="paper-notes" />
<meta property="article:published_time" content="2023-01-01T00:00:00-06:00" />
<meta property="article:modified_time" content="2023-01-01T00:00:00-06:00" />




<link rel="canonical" href="http://www.viveksyngh.com/paper-notes/merkle-tree-and-its-applications/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.65236a6d834b26194eed04a2a3b45e44d9194ef9e620253705d4bef03bd7ef81.css" integrity="sha256-ZSNqbYNLJhlO7QSio7ReRNkZTvnmICU3BdS&#43;8DvX74E=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.f6534b0b446b75d9b6ad77a97d43ede2ddaeff1b6e2361fb7198d6f8fcb7f83f.css" integrity="sha256-9lNLC0Rrddm2rXepfUPt4t2u/xtuI2H7cZjW&#43;Py3&#43;D8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Vivek Kumar Singh
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/paper-notes/">Paper Notes</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/resources/">Resources</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/system-design/">System Design</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blogs</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container page">
  <article>
    <header>
      <h1 class="title">
        <a class="title-link" href="http://www.viveksyngh.com/paper-notes/merkle-tree-and-its-applications/">
          Merkle Tree and It’s Applications
        </a>
      </h1>
    </header>

    <p>A Merkle tree, also known as hash tree is a <em>hash based</em> data structure. It is a tree data structure in which each node <em>leaf</em> nodes are cryptographic hash of data blocks for example a file or set of files, and each <em>non-leaf</em> node is cryptographic hash on its children nodes. A hash tree allows <em>efficient</em> and <em>secure verification</em> of the contents of a large data structure.</p>
<p>Merkle trees are used in distributed systems for efficient data verification. Merkle tree uses hashes instead of full files or content for data verification which makes it efficient as it avoid transfer of large files for verification of the data.</p>
<p>Typically, a Merkle tree is implemented as a <em>binary tree</em>, means each node has at most 2 children nodes. <em>Leaf nodes</em> of the tree are hash of the actual content such as files, data blocks etc. <em>Non-leaf</em> nodes are hash of the concatenation of its two children nodes hashes.</p>
<p><img src="../../images/paper-notes/merkle-tree-1.webp" alt="Merkle Hash Tree - 1"></p>
<p>[Merkle Hash Tree-1]</p>
<p>The hash function h is a one-way cryptographic hash function such as <em>MD5</em> or <em>SHA256</em> etc.</p>
<h2 id="building-merkle-tree">
  Building Merkle Tree
  <a class="heading-link" href="#building-merkle-tree">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Begin by building a tree in which leaves correspond to the ordered elements in the set, and have each leaf node contain the hash value of its element. Proceed up to the next level in the tree, creating internal nodes which correspond to the hash value of the concatenation of its children (maintaining their order). An internal node whose children are <code>v1</code> and <code>v2</code> will therefore have the value <em>h(v1||v2)</em> . Continue this process of building the higher levels in the tree until the root has been formed. This construction is referred to as a Merkle Hash Tree (MHT). The root hash is also known as <em>Merkle root</em>.</p>
<h2 id="merkle-audit-paths-or-inclusion-proof">
  Merkle Audit Paths or Inclusion Proof
  <a class="heading-link" href="#merkle-audit-paths-or-inclusion-proof">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>A Merkle audit path for a leaf in a Merkle Hash Tree is the shortest list of additional nodes in the Merkle tree required to compute the Merkle Tree Hash for that tree. In other words, The Merkle audit Path is the missing node hashes required to compute all of the nodes between the leaf and the tree root. If the root hash you compute from the audit path matches the currently advertised Merkle tree hash for the log, then the leaf exists in the tree. This is used to verify if a leaf node exists in a Merkle tree or not.</p>
<p>In the above <em>MHT</em>, The Merkle audit path for leaf node 3 is <em>[h2, h34]</em></p>
<p><img src="../../images/paper-notes/merkle-tree-2.webp" alt="Merkle Hash Tree - 2"></p>
<p>If we use the nodes in audit path we can calculate the Merkle root. Using h2 and h1 (which is hash of 3 that we already know) we can get <code>h12</code> . Now using <code>h12</code> and <code>h34</code> we can get root of the Merkle hash tree. If the calculated hash of the root and existing MHT hash are equal it means that 3 exists in the tree.</p>
<p>Merkle audit path for leaf node 6 is [h4, h12]</p>
<p><img src="../../images/paper-notes/merkle-tree-3.webp" alt="Merkle Hash Tree - 3"></p>
<h2 id="consistency-proof">
  Consistency Proof
  <a class="heading-link" href="#consistency-proof">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>A Merkle consistency proof lets you verify that any two versions of a Merkle hash tree are consistent: that is, the later version includes everything in the earlier version, in the same order, and all new entries come after the entries in the older version. Merkle consistency proofs prove the append only property of the tree.</p>
<p>If you can prove that a Merkle hash tree is consistent it means that no entries have been back-dated and inserted into the Merkle hash tree, no entries have been updated in the MHT, and the MHT has never been branched or forked.</p>
<p>For example, these two Merkle hash trees are built incrementally from the first tree above.</p>
<p><img src="../../images/paper-notes/merkle-tree-4.webp" alt="Merkle Hash Tree - 4"></p>
<pre><code>[Merkle Hash Tree-2]
</code></pre>
<p><img src="../../images/paper-notes/merkle-tree-5.webp" alt="Merkle Hash Tree - 5"></p>
<pre><code>[Merkle Hash Tree-3]
</code></pre>
<p>The consistency proof between Merkle hash tree 1 and Merkle hash tree 3 is <em>[h78]</em>. The Merkle has tree 3 can be verified using the <em>h14</em> which is tree 1 (already given) and <em>h78</em>.</p>
<p>The consistency proof between Merkle hash tree 2 and Merkle hash tree 3 is <em>[h14, h56, h78]</em>. <em>h14, h56</em> are used to verify Merkle hash tree 2, and <em>h78</em> is additionally used to show hash is consistent with Merkle tree hash 3.</p>
<h2 id="features">
  Features
  <a class="heading-link" href="#features">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Some of the features of Merkle tree.</p>
<h3 id="efficiency">
  Efficiency
  <a class="heading-link" href="#efficiency">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>In distributed and P2P systems data verification is very important because the same data exists in multiple locations. So, if a piece of data is changed in one location, it’s important that data is changed everywhere. Data verification is used to make sure data is the same everywhere.</p>
<p>However, it is time consuming and computationally very intensive to send the entire file or data for the verification in a distributed systems whenever a system wants to verify data. This is why Merkle trees are used. It basically limits the amount of the data being sent over a network by just sending the hash of the data or file instead of entire data or file. Plus, if an inconsistent piece of data is found, it’s much easier to insert a small chunk of fixed data than to completely rewrite the entire file to fix the issue.</p>
<h3 id="trust">
  Trust
  <a class="heading-link" href="#trust">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Merkle trees are useful in peer-to-peer systems is that they help you verify information, even if some of it come from an untrusted source (which is a concern in peer-to-peer systems). Before you download a file from a peer-to-peer source — like Tor — the root hash is obtained from a trusted source. After that, you can obtain lower nodes of the Merkle tree from untrusted peers. All of these nodes exist in the same tree-like structure described above, and they all are partial representations of the same data. The nodes from untrusted sources are checked against the trusted hash. If they match the trusted source (meaning they fit into the same Merkle tree), they are accepted and the process continues. If they are no good, they are discarded and searched for again from a different source.</p>
<h2 id="applications">
  Applications
  <a class="heading-link" href="#applications">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Merkle tree is used by many software systems. Some of it’s popular applications are as follows</p>
<h3 id="peer-to-peer-network-systems-such-as-tor-bitcoin-ethereum-etc">
  Peer to Peer Network systems such as Tor, Bitcoin, Ethereum etc
  <a class="heading-link" href="#peer-to-peer-network-systems-such-as-tor-bitcoin-ethereum-etc">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>In P2P systems data verification is very important because the same data exists in multiple locations. So, if a piece of data is changed in one location, it’s important that data is changed everywhere. Data verification is used to make sure data is the same everywhere.</p>
<p>Merkle tree makes this data verification efficient because they use hashes instead of full files or data. Hashes are ways of encoding files that are much smaller than the actual file itself.</p>
<p>For example,</p>
<p>In <a href="https://www.investopedia.com/terms/b/bitcoin.asp"  class="external-link" target="_blank" rel="noopener">bitcoin’s blockchain</a> , a block of transactions is run through an algorithm to generate a <a href="https://www.investopedia.com/terms/h/hash.asp"  class="external-link" target="_blank" rel="noopener">hash</a>, which is a string of numbers and letters that can be used to verify that a given set of data is the same as the original set of transactions, but not to obtain the original set of transactions.</p>
<p>The Merkle tree is useful because it allows users to verify a specific transaction without downloading the whole blockchain (over 445 gigabytes at the time of writing this blog).</p>
<h3 id="distributed-database-systems-such-as-dynamodb-riak-cassandra">
  Distributed Database systems such as DynamoDB, Riak, Cassandra
  <a class="heading-link" href="#distributed-database-systems-such-as-dynamodb-riak-cassandra">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Distributed database systems uses Merkle tree to implement replica synchronisation (anti-entropy) protocol to keep the replicas synchronised. Merkle tree helps to detect the inconsistencies between replicas faster, minimise the amount of transferred data and reduce the number of disk reads performed during the replica synchronisation process. For example, <em>Cassandra replica synchronisation works as follows</em></p>
<p>A node initiates the replica synchronisation process, also known as initiating node. Each participating nodes for a replica builds its own Merkle hash tree and shares with the initiating nodes. The initiating nodes compares every tree to every other tree. If a difference is detected, the differing nodes exchange data for the conflicting range(s), and the old data is replaced with new data. The comparison begins with the top node of the Merkle tree. If no difference is detected, the process proceeds to the left child node and compares and then the right child node. When a node is found to differ, inconsistent data exists for the range that pertains to that node. All data that corresponds to the leaves below that Merkle tree node will be replaced with new data.</p>
<p>Read more about Cassandra anti-entropy feature <a href="https://docs.datastax.com/en/cassandra-oss/3.x/cassandra/operations/opsRepairNodesManualRepair.html"  class="external-link" target="_blank" rel="noopener">here</a></p>
<h3 id="certificate-transparency">
  Certificate Transparency
  <a class="heading-link" href="#certificate-transparency">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Certificate transparency aims to mitigate the problem of mis issued certificates by providing publicly auditable, append-only, untrusted logs of all issued certificates. The logs are publicly auditable so that it is possible for anyone to verify the correctness of each log and to monitor when new certificates are added to it.</p>
<p>Each log consists of certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly issued certificates to one or more logs; it is also expected that certificate holders will contribute their own certificate chains.</p>
<p>Merkle trees as used to maintain logs. The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs.</p>
<p>Learn more about Certificate Transparency and how it works from <a href="https://datatracker.ietf.org/doc/html/rfc6962"  class="external-link" target="_blank" rel="noopener">RFC6962</a> and <a href="https://certificate.transparency.dev/"  class="external-link" target="_blank" rel="noopener">https://certificate.transparency.dev/</a></p>
<p>I have implemented a Merkle tree which uses SHA256 as a hash function.</p>
<p><a href="https://github.com/viveksyngh/merkletree"  class="external-link" target="_blank" rel="noopener">https://github.com/viveksyngh/merkletree</a></p>
<p>References:</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6962"  class="external-link" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc6962</a></li>
<li><a href="https://github.com/google/trillian/blob/master/docs/papers/VerifiableDataStructures.pdf"  class="external-link" target="_blank" rel="noopener">https://github.com/google/trillian/blob/master/docs/papers/VerifiableDataStructures.pdf</a></li>
</ul>

  </article>
</section>

  

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2023 -
    
    2024
     Vivek Kumar Singh 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>